#    -*- mode: org -*-
#+OPTIONS: reveal_center:t reveal_progress:t reveal_history:t reveal_control:t
#+OPTIONS: reveal_mathjax:t reveal_rolling_links:t reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS: reveal_width:1200 reveal_height:800
#+OPTIONS: toc:0
#+OPTIONS: creator:0
#+OPTIONS: author:false
#+OPTIONS: timestamp:0
#+REVEAL_CONTROLS: false
#+REVEAL_MARGIN: 0.2
#+REVEAL_MIN_SCALE: 0.5
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_TRANS: none
#+REVEAL_THEME: night
#+REVEAL_EXTRA_CSS: ./reveal.js/lib/css/zenburn.css
#+REVEAL_EXTRA_CSS: ./presentation.css

#+OPTIONS: reveal_title_slide:"<h1>%t</h1>"
#+TITLE: Practical Dependent Types

* Disclaimer!

** I am no expert. Most everything here is gleaned from:

   1. The Idris tutorial I half started last week
   2. The Wikipedia article on Dependent Types
   3. Like 2 Youtube videos and various podcasts

* Problem:

** It is nigh impossible to prove our programs do what we say they do.

** Tests typically used to capture this specification

** Testing all states is hard:

   - For a function \( f \) of \( n \) arguments \( f:(X_1,..., X_n) \mapsto Y \) , there are \( \prod_{i=1,n} |X_i| \) possible inputs
   - i.e. \(g\), below, has \(2 \times 2 \times 2 \) inputs

   #+begin_src haskell
g :: Bool -> Bool -> Bool -> Bool
   #+end_src

** Property testing gets more cases

** ~forAll~ in QuickCheck is still not \(\forall\)

* What we need are /proofs/

** Curry-Howard isomorphism

   *(yes, that Curry)*

   - Every function in typed lambda calculus is a proof in intuitionist logic
   - (no excluded middle, no double negation)

** That sounds like the ticket!

   We just need one thing (from my limited research)

** Dependent Types

   - Types that depend on values
   - Link mathematical theory of logic to type systems
   - Stand for universal quantifiers ( \forall, \exists ) in predicate logic

** Worth a google

   - /Propositions as Types/ - Philip Wadler
   - Various typed lambda calculi (like System F of Haskell fame)

* Prior Art

** Agda, Coq, and a ton of others

   - What sets apart the modern dependent type technologies is their usefulness to the average business programmer
   - (Not to say any of the others aren't, but Idris puts the business user first)

** Haskell has had some form of dependent types as of GHC 8

   - [[https://www.schoolofhaskell.com/user/konn/prove-your-haskell-for-great-safety/dependent-types-in-haskell][Like in this blog]]
   - And as a library for longer via [[https://ucsd-progsys.github.io/liquidhaskell-blog/][LiquidHaskell]]

* Idris

** Centered around being a practical dependently typed technology

** Expressive types /and/ formal specification at once!

** Interactive proving!

   - Not unique to Idris, but worth a mention

** Just hit 1.0!

   #+begin_src yaml
# In ~/.stack/global-project/stack.yaml
extra-deps: [ code-page-0.1.3 ]
resolver: lts-9.0
   #+end_src

   #+begin_src shell
# Outside of a Haskell project
stack install idris-1.0
   #+end_src


** Sample code!

*** A vector of specific length

    #+begin_src idris
data Vect : Nat -> Type -> Type where
     Nil : Vect Z a
     (::) : a -> Vect k a -> Vect (S k) a
    #+end_src

* If it compiles, ship it!
